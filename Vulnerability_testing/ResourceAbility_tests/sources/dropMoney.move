module testing::M_module{
    struct Money { value: u64 }

    public fun new_money(val: u64): Money {
        Money{ value: val }
    }

    public fun sum_money(money: &mut Money, money2add: Money) {
        let Money{value: val2add} = money2add;
        let value = &mut money.value;
        *value = *value + val2add;
    }

    //Function is unnecessary if the Money struct has the drop ability
    public fun destroy(money: Money){
        Money{value: _} = money;
    }
}

module testing::W_module {
    use testing::M_module;

    struct Wallet {
        money: M_module::Money
    }

    public fun new_wallet(): Wallet {
        Wallet{money: M_module::new_money(0)}
    }

    public fun add_money(wallet: &mut Wallet, money: M_module::Money) {
        M_module::sum_money(&mut wallet.money, money);
    }

    //Function is unnecessary if the Wallet struct has the drop ability
    public fun destroy(wallet: Wallet){
        let Wallet{money: _m} = wallet;
        M_module::destroy(_m); //Not needed: Money struct is drop-able
    }
}

#[test_only]
module testing::dropTest{
    use testing::M_module;
    use testing::W_module;

    #[test]
    fun test_increment() {
        let wallet = W_module::new_wallet();
        let _money = M_module::new_money(30);
        W_module::add_money(&mut wallet, _money); //Not consuming money
        W_module::destroy(wallet); //Needed: Wallet struct not drop-able
    }
}

